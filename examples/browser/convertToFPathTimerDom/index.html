<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1, width=device-width" />
    <!-- prevent favicon request -->
    <link href="data:;base64,iVBORw0KGgo=" rel="icon" />
    <title>Convert To F Path Timer Dom</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="container">
      <div class="content">
           <svg width="100%"  class="graph"><g transform="translate(50,100)"/></svg>
           <div class="content__convertToF">
            <form  class="convertToF">
              <label class="label-input"     for="inputValue"> Celsius</label>
              <input class="inputValue"      type="text"  id="inputValue" name="input" size="10" value=" ">
              <input class="buttonCalculate" id="buttonCalculate"   name="buttonCalculate" type="button" value="calculate"/>
              <label class="label-output"    for="outputDisplay">Fahrenheit</label>
              <output class="outputDisplay"  id="outputDisplay"> </output>
            </form>
          </div>
          <div class="content__message">
            <p>This a simple/naive solution:</p>
            <ul>
              <li>No input validation</li>
              <li>No error handling</li>
              <li>etc</li>
            </ul>
          </div>
       </div>
     </div>

  <script src="js/xstate.js"></script> 
  <script src="js/d3.v5.min.js"></script>
  <script src="js/dagre-d3.min.js"></script>
  <script src="js/grammarXstate.js"></script>
  <script src="js/grammarDagreD3.js"></script>
  <script src="js/utils.js"></script>

  <script>

/**
 *     
 *                      SETUP
 *  
 *
 **/

   const { Machine,  interpret, assign } = XState; 
   const buttonCalculate                 = document.getElementById('buttonCalculate');
   const inputValue                      = document.getElementById('inputValue');
   const ouputDisplay                    = document.getElementById('outputDisplay');
   const ParserXstate                    = grammarXstate.Parser;
   const parserXstate                    = new ParserXstate(grammarXstate);
   const createMachineConf               = input => parserXstate.parse(input);
   const ParserDagredD3                  = grammarDagreD3.Parser;
   const parserDagredD3                  = new ParserDagredD3(grammarDagreD3);
   const prevStateCurrState              = ['INITIAL'];

   buttonCalculate.addEventListener('click', () => convertToFMachineService.send('calculate'));

   function  getInput(ctx,evt)  {
    let value = new Promise(  
                   function(resolve, reject){
                      setTimeout(resolve, 1000, inputValue.value); 
                    }
               );

    return value.then(celsius => celsius);
   }

   
   function  calcF(ctx,evt)  {
    let value = new Promise(  
                   function(resolve, reject){
                      setTimeout(resolve, 1000,(ctx.celsius * (9/5) + 32)); 
                    }
               );
     
     return value.then(fahrenheit => fahrenheit);
   }


   function  displayResult(ctx,evt)  {
    outputDisplay.textContent = ctx.result;

    let checkDom  = new Promise(  
                   function(resolve, reject){
                     setTimeout(
                       function() {
// unary plus operator (+) attempts to convert its operand into a number
                         if( +outputDisplay.textContent === ctx.result) {
                          resolve();
                         } else {
                          reject();  
                         }
                       },
                       1000); 
                    }
               );

     return checkDom;

    }


   const stateTransitionTable =
`
context:
  celsius: ""
  result:  "" 

 invoke:
     id: getinput
    src: getinput
 ondone: CALCF            :setctxcelsius
onerror: ERROR

 invoke:
     id: calcf
    src: calcf 
 ondone: DISPLAYRESULT    :setctxresult
onerror: ERROR

 invoke:
     id: displayresult 
    src: displayresult
 ondone: IDLE              :setctxcelsiusstr :setctxresultstr
onerror: ERROR

*IDLE            calculate        READINPUT
 READINPUT       @getinput        
 CALCF           @calcf           
 DISPLAYRESULT   @displayresult  
 ERROR                                 
`;


   const convertToFMachineConf = createMachineConf(stateTransitionTable); 

// xstate expects an object
   const options = {
     actions: {
       setctxcelsius:    assign({celsius: (ctx,evt) => evt.data}),
       setctxresult:     assign({result: (ctx,evt)  => evt.data}), 
       setctxcelsiusstr: assign({celsius: (ctx,evt) => ""}),
       setctxresultstr:  assign({result: (ctx,evt)  => ""})
     },
     services: {
       getinput:         getInput,
       calcf:            calcF,
       displayresult:    displayResult
     }
 };


   const convertToFMachine = Machine(convertToFMachineConf,options);

    convertToFMachineService   = interpret(convertToFMachine)
        .onTransition(state => {
          console.log('state   ',state.value);
          console.log('celsius ',state.context.celsius);
          console.log('result ', state.context.result);
          console.log('---------------------------------');
          highlightCurrentPath(state,prevStateCurrState);
        }
    );



/**
 *     
 *      GRAPH
 *  
 *
 **/

   var g = new dagreD3.graphlib.Graph().setGraph({rankdir: 'LR'});

   let arr = parserDagredD3.parse(stateTransitionTable); 
   let states = arr[0];
   let edges  = arr[1];

  
   states.forEach(function(state) {
       if(state === "FINAL" || state === "INITIAL"  ) {
         g.setNode(state, { label: "" }); 
         g.node(state).style = "fill: #333";
       } else {
         g.setNode(state, { label: state }); 
       }
   });

   edges.forEach( function(ele) { g.setEdge(ele[0], ele[1], { label: ele[2]}); });

   // Set some general styles
   g.nodes().forEach(function(v) {
     var node = g.node(v);
     node.rx = node.ry = 10;
   });

 
   var svg = d3.select("svg"), inner = svg.select("g");
   
   // Set up zoom support
   var zoom = d3.zoom().on("zoom", function() {
         inner.attr("transform", d3.event.transform);
       });

   svg.call(zoom);
   
   // Create the renderer
   var render = new dagreD3.render();
   
   // Run the renderer. This is what draws the final graph.
   render(inner, g);
   
 
  var initialScale = 2;
  svg.attr('height', g.graph().height * initialScale + 40);




/**
 *     
 *      MAIN 
 *  
 *
 *  convertToF(0)    should return a number
 *  convertToF(-30)  should return a value of   -22
 *  convertToF(-10)  should return a value of   14
 *  convertToF(0)    should return a value of   32
 *  convertToF(20)   should return a value of   68
 *  convertToF(30)   should return a value of   86
 *
 **/

   convertToFMachineService.start();
  
  </script>
</body>
</html>



